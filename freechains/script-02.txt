=== 01

Essa é a segunda parte do vídeo.

=== 02

O Freechains * é um sistema publish-subscribe baseado em tópicos e com
persistência de dados.
Cada tópico *, chamado de "cadeia", é representado aqui por um plano * * * *.

A disseminação * segue o modelo de "gossip" onde os nós da rede, cada um aqui
* representado por um retângulo *, se comunicam par a par *.

Como já discutido, * o Freechains ordena as postagens dos autores com ordem
parcial de causalidade e melhor esforço.
Eventos que tem relação de causa e efeito, por exemplo *, uma pergunta
seguida de uma resposta, vão ter sempre a ordem preservada.
Mas eventos sem relação, por exemplo *, duas respostas independentes, podem ser
recebidas em ordem diferentes nos nós da rede.

A maior inovação do Freechains *, é o seu sistema de reputação que ainda será
apresentado.
Cada cadeia possui um sistema independente que vai servir para manter a
qualidade das postagens e autores.

=== 03

Na prática, * o Freechains é um software de código aberto que pode ser baixado
e instalado em um computador ou celular.

O Freechains executa em background * como um servidor ou daemon que escuta
requisições de usuários locais * ou e se comunica * com outros nós da rede.

O daemon podr ser acessado * de três formas equivalentes:
- pela * linha de comando, que iremos usar no resto da apresentação
- por * uma API em kotlin, que pode ser usada para criar aplicações em cima do
  freechains
- ou ainda * diretamente pelo protocolo, que permite usar outras linguagens
  através de sockets. o protocolo é inteiramente textual e pode inclusive ser
  acessado via telnet para interações simples ou para fins didáticos

=== 04

Aqui então *, vamos usar o comando "freechains" na linha de comando de um
sistema Linux.
O comando "host create" inicializa a estrutura de diretórios de um host no
diretório passado.
Ele só precisa ser executado uma única vez.

Em seguida *, iniciamos o daemon em background com o comando "host start"
passando o diretório de criação.
Nesse momento * temos o daemon preparado para receber requisições de seus
usuários.
Em teoria, é possível ter mais de um peer executando na mesma máquina mas em
diretórios diferentes e se usarmos portas diferentes no comando de criação.

Os mesmos comandos * podem ser executados em outras máquinas * localmente, mas
ainda não há qualquer tipo de comunicação entre elas.

=== 05

Agora vamos exemplificar a comunicação usando uma identidade pública.
Primeiro *, precisamos criar um par de chaves único para o usuário.
A resposta * são duas chaves bem longas: a chave pública com 64 caracteres e a
chave privada com 128 caracteres.
Usamos os pontinhos para as chaves caberem na tela.
A chave privada obviamente deve ser guardada em segredo.
A chave pública é a identidade deste usuário que deve ser compartilhada com o
seu público de interesse.
Sempre que uma postagem for assinada com essa chave, significa que foi postada
pelo usuário que guardou a chave privada.

Agora *, usamos o comando "chain join" para criar uma cadeia localmente *.
Aqui o comando recebe dois parâmetros quase iguais.
O primeiro parâmetro é o nome da cadeia que deve sempre começar por uma barra.
O segundo parâmetro é a chave pública a ser associada a essa cadeia.
Ou seja, essa cadeia foi criada para que esse usuário possa disseminar o seu
conteúdo para outros usuários.
Usamos a chave no nome da cadeia como uma simples convenção, já que os outros
usuários precisam saber a chave pública de qualquer maneira.

Essa não é a única maneira de se criar cadeias.
O comando a seguir *, cria uma cadeia "/chat" sem uma chave pública associada.
Esse tipo de cadeia vai ser usado na comunicação N pra N que ainda iremos
discutir.

Voltando à cadeia com chave pública, chamamos de dono aquele que possui a chave
privada associada a ela.
O dono da cadeia possui reputação infinita e pode moderar o conteúdo como bem
entender.
Já um outro usuário precisa de reputação para postar.
O mecanismo é o mesmo que vai ser explicado para cadeias N pra N.
Também é possível criar uma cadeia que apenas o dono possa postar.

Agora vamos considerar um outro host * que um outro usuário também criou a
mesma cadeia * localmente.
Esse usuário não possui a chave privada associada, ou seja, ele é um consumidor
do padrão 1 pra N.

Mesmo sendo criadas em hosts diferente e de maneira independete, as cadeias são
a mesma pois têm os mesmos parâmetros.
Podemos verificar isso acessando * a primeira postagem que existe
implicitamente em qualquer cadeia.
Chamamos essa postagem de "gênesis" e o que obtemos como resposta * do comando
é o código hash dela.
Esse código vai ser o mesmo em qualquer host para suma dada mesma cadeia.
Aqui * temos um diagrama da cadeia com a postagem gênesis sempre existente.

Finalmente, vamos postar um conteúdo novo * usando a chave privada.
O comando "chain post" cria uma postagem nova localmente.
O conteúdo vai ser passado "inline" no próprio comando como utf8 como
"Hello World!".
Nesse caso, assinamos a postagem com a chave privada do dono da cadeia.

Podemos ver * que um novo bloco aparece na cadeia apontando para o bloco
gênesis.
Os prefixos "0_" e "1_" no código do bloco indicam a sua altura na cadeia.

O estado da cadeia ainda é local e o novo conteúdo ainda não foi efetivamente
disseminado.
