=== 01

This is the second part of the video.

=== 02

Freechains * is a topic-based publish-subscribe system with data persistence.
In other words, we have topics * or groups * represented here by the planes *.
We call * them as "chains".
And when a participant posts a content to a chain, all other participants
subscribed to that chain will receive the post.
We consider the chains to be persistent because from a given post it is
possible to reach all other posts from the past.

The dissemination * follows a "gossip" model in which the peers in the network
*, each one here represetned * as a rectangle, communicate peer * by peer.

As we already discussead *, Freechains order the authors' * posts with a
happened-before relation with best effort.
Events that have a cause and effect, for example *, a question followed by its
answer will always have the order preserved.
But independent events, for example * two answers for the same question, might
be delivered in different orders by the peers in the network.

Our main contribution with Freechains * is a decentralized reputation system to
be presented.
Each chains has its own independent system to keep the quality of posts and
authors.

=== 03

In practice, * Freechains is an open-source software that can be downloaded
and installed on a computer or mobile phone.

Freechains * executes in the background as a server or daemon that listens to
loca user * requests and communicates * with other peers in the network.

The daemon * can be accessed in three equivalent ways:
- from * the command line, which we will use in the rest of the presentation
- from * an API em Kotlin, which can be used to create applications on top of
  Freechains
- or yet * directly from a textual protocol that permits to use other languages
  via sockets.

=== 04

Let's now use "freechains" * from the command line in Linux.
The command "host create" initializes * a local file structure of a host in the
given directory.
This command only needs to be executed once.

Then *, we start the daemon in background with the command "host start"
passing the directory of creation.
Now * users can connect and issue commands to Freechains.

The same commands * can be execute in other machines * locally to prepare the
network, but there's still no communication among them.

=== 05

Now let's give an example of communication using a public identity.
That is, an author *, for example a news site, wants to broadcast its content *
for a target * public, which can provide * some feedback.

=== 06

First *, we need to create a pair of keys for the author.
The command "crypto create" derives a public and private key from the given
passphrase.
The answer * is a pair of keys: a public shorter and a private longer, which
should be kept safe in secret.
The public key is the identity of this author and should be shared with its
target audience.
Whenever a post has this public signature, it means that it was posted by the
user holding the private key.

Now *, we use the command "chain join" to create a chain locally *.
Here, the command receives two arguments that are almost the same.
The first is the name of the chain that always starts with a slash.
The second argument is the public key associated with the chain.
This chain was created so that this user can disseminate its content for other
participants.
We use the key in the name of the chains as a convenience, since the other
users already need to know the public key.

Chains for public identities are not the only kind of chains.
The next command * create the chain "slash chat" withouth any associated public
key.
This kind of chain will be used in N-to-N communication that we will discuss in
the future.

Going back * to the public identity chain, we call its owner who controls the
private key.
The owner has infinite reputation and can moderate the content of the chain.

Now, let's consider another user that uses the same * command to join the chain
in another host *, creating the same chain * locally.
This user doesn't have the private key, so he's a consumer in the 1-to-N
communication pattern.

Even if the chains were created in different hosts independently, they chains
are the same because they were created with the same arguments.
We can verify that with the command "chain genesis" *, which reads the first
post the exists in the chain implicitly.
We call this post as the "genesis block" and obtain as an answer * its hash
code.
We can verify that this hash code will be the same in any host for a given
chains.
Here *, we have a diagram of the chain with the genesis block.

Finally, we post a new content * using the private key.
The command "chain post" creates a new post locally and points * to the set of
existing blocks in the chains to comply with the best-effort strategy.
The prefixes "0_" e "1_" in the blocks indicate their height in the chain.
In the command, the contents are passed "inline" as "Hello World!".
It's also possible to give a file name here.
The post is signed with the given private key.

The state of the chain is local and the content were not disseminated yet.

=== 07

Vamos recriar os passos do slide anterior.
A nossa autora *, Maria, está conectada * a um computador com o Freechains.
Primeiro *, ela cria uma identidade * com o comando "crypto create".
Aí ela divulga a sua chave pública e guarda a sua chave privada

Ela então usa o comando * de "join", que cadastra * a sua cadeia no host já
com o bloco "gênesis" *.

Em seguida *, Maria posta uma mensagem na cadeia com o comando "chain post" e
usa a sua chave privada para assinar.

Por outros meios *, a Maria divulga somente a sua chave pública para João *,
que está conectado em outra máquina * ao Freechains
Como a identidade de Maria é pública, João pode repassá-la * a outros amigos
que possam ter interesse no conteúdo de Maria, mesmo sem conhecê-la.

Esses outros usuários agora * podem usar o comando de "join" para também se
cadastrarem * na cadeia de Maria.
Maria também pode ter um computador * no seu trabalho ou o seu próprio celular
que pode ser usado alternativamente até como backup da sua cadeia.

Finalmente, para disseminar o conteúdo da cadeia, o usuário deve usar o comando
"chain send" *, que irá enviar todos os blocos que o destino ainda não tem *.
João também deve repassar o conteúdo a frente *, já que Maria não tem contato
direto com todos os seus seguidores.
Esse é exatamente o processo de "gossip" ou "fofoca" entre os pares que o
Freechains usa pra disseminar o conteúdo.
O comando de envio é unidirecional e único, ou seja, não é periódico.
Claro que é possível automatizar o envio para ser bi-direcional e periódico,
mas isso deve ser feito por fora do protocolo como uma outra aplicação.

Uma última observação.
A máquina que Maria usou para postar a mensagem não tem nenhum privilégio
especial, a única autoridade aqui é a sua chave privada, que pode ser usada *
em outra máquina sem nenhum problema.

=== 8

Agora vamos exemplificar uma comunicação em forums públicos.
Ou seja, os autores não se conhecem, nem há uma autoridade suprema sobre a
cadeia e ainda é possivel que haja usuários maliciosos.

=== 09

Uma cadeia pública é moderada por um sistema de reputação autônomo com auxílio
dos seus próprios usuários.

João * gosta de cozinhar e teve a idéia * de criar uma cadeia no Freechains para
compartilhar receitas.
Ele imediatamente posta * o objetivo do grupo com a sua assinatura e convida *
outros amigos a participarem.
Por ter assinado o primeiro bloco da cadeia, João é recompensado com +30 "reps"
* que é a unidade de reputação do sistema.

Uma questão que pode ser imediatamente levantada é que um outro usuário * em
qualquer lugar do mundo pode ter tido a mesma idéia e também gostaria de ser
recompensado com +30 reps por ter criado a cadeia.
De fato, os nomes das cadeias são livres, não existe um sistema centralizado
de registro de nomes.
Também não tem nenhum problema em que essas cadeias co-existam, desde que elas
nunca precisem se sincronizar.
Ou seja, se o Alan * ou qualquer membro cadeia tentar se sincronizar com a
outra cadeia, a operação irá falhar já no bloco após o gênesis.
As cadeias são incompatíveis.

Voltando * a cadeia original, Maria tenta postar * uma nova receita, que entra
* na cabeça da cadeia.
Mas como ela ainda não tem reputação, o bloco é inicialmente bloqueado
e aguarda um LIKE para ser aceito.
Por enquanto, somete o João consegue aprovar blocos novos.
Ele aprova o conteúdo e dá um like * na postagem de Maria que passa a ser
aceita na cadeia.
Essa reputação é transferida * entre os dois autores.
João recebe -1 rep e Maria +1 rep.
Só que uma postagem nova conta negativamente para o autor por 24 horas.
Então *, Maria ainda é penalizada com -1 rep o que impede que ela poste
novamente.
Após as 24 horas, a postagem passa a contar positivamente * e Maria agora passa
a ter +2 reps que ela pode usar pra postar ou moderar outras postagens.

=== 10

Algumas considerações sobre o sistema de reputação

***

- O primeiro autor está 30 dias a frente e molda a cultura inicial da cadeia.
***
- Também só é possível haver um primeiro autor em uma dada cadeia.
  Hosts que discordem, nunca irão se sincronizar.

***

Novos autores necessitam de aprovação inicial da comunidade e obtêem um
crescimento lento.

***

Novas postagens são inicialmente penalizadas.
***
Isso significa que os autores devem medir as palavras
***
Pois o volume de posts não é recompensado, apenas a sua qualidade.

***

Postagens consolidados formam a economia da comunidade, já que são a única
forma de produção, mas ainda estão sujeitas a moderação posterior.

=== 11

No próximo vídeo, vamos detalhar melhor o sistema de reputação.
